use clap::Parser;

use rusqlite::Connection;

use std::fs::File;
use std::io::{BufRead, BufReader, Read};

// fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {
//     std::any::type_name::<T>()
// }

// Three rows generated by default
const DEFAULT_ROWS: usize = 3;

fn create_table_stmt(name: &str) -> String {
    format!(
        r#"DROP TABLE IF EXISTS {0};
CREATE TABLE {0} ( file_name TEXT, line_number INTEGER, line TEXT);
"#,
        name
    )
}

fn alter_table_stmt(table_name: &str, col_name: &str, col_type: &str) -> String {
    format!(
        r#"ALTER TABLE {} ADD COLUMN {} {};"#,
        table_name, col_name, col_type
    )
}

fn generate_insert_and_alter(re: &regex::Regex, table_name: &str) -> (String, String) {
    let mut insert_stmt = format!("insert into {} values(?1, ?2, ?3", table_name);
    let mut alter_table_stmts = String::new();

    let iter = re.capture_names().skip(1); // First item is whole match
    for (i, c) in iter.enumerate() {
        insert_stmt.push_str(&format!(", ?{}", i + DEFAULT_ROWS + 1));

        match c {
            Some(n) => alter_table_stmts.push_str(&alter_table_stmt(table_name, n, "TEXT")),
            None => alter_table_stmts.push_str(&alter_table_stmt(
                table_name,
                &format!("group{}", i + 1),
                "TEXT",
            )),
        };
    }

    insert_stmt.push_str(");");

    (insert_stmt, alter_table_stmts)
}

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(short, long)]
    database: String,
    #[clap(short = 'e', long)]
    pattern: Option<String>,
    #[clap(short = 'f', long)]
    pattern_file: Option<String>,
    #[clap(short, long)]
    same_table: Option<String>,
    #[clap(short, long)]
    non_matching: bool,
    #[clap(last = true)]
    files: Vec<String>,
}

fn escape(s: &str) -> Result<String, std::string::FromUtf8Error> {
    String::from_utf8(
        s.bytes()
            .map(|b| if b.is_ascii_alphabetic() { b } else { b'_' })
            .collect::<Vec<u8>>(),
    )
}

fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    let re_str = match (args.pattern_file.as_deref(), args.pattern.as_deref()) {
        (Some("-"), None) => {
            let stdin = std::io::stdin();
            let mut reader = BufReader::new(stdin);
            let mut buf = vec![];
            reader.read_to_end(&mut buf)?;
            String::from_utf8(buf).unwrap().trim_end().to_owned()
        }
        (Some(f), None) => std::fs::read_to_string(f)?.trim_end().to_owned(),
        (None, Some(s)) => s.to_owned(),
        (Some(_), Some(_)) => {
            return Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Mutually exclusive options",
            )));
        }
        _ => String::new(),
    };

    let re = regex::RegexBuilder::new(&re_str).build()?;
    let db = Connection::open(&args.database)?;

    if args.same_table.is_some() {
        db.execute_batch(&create_table_stmt(args.same_table.as_deref().unwrap()))?;
    }

    let mut insert_non_matching_stmt = if args.non_matching {
        db.execute_batch(&create_table_stmt("non_matching"))?;
        let (i, _) = generate_insert_and_alter(&regex::Regex::new("")?, "non_matching");
        Some(db.prepare(&i)?)
    } else {
        None
    };

    for filename in args.files {
        let table_name = match args.same_table.as_deref() {
            Some(n) => n.to_owned(),
            None => {
                let t = escape(&filename)?;
                db.execute_batch(&create_table_stmt(&t))?;
                t
            }
        };

        let (insert_stmt, alter_table_stmts) = generate_insert_and_alter(&re, &table_name);
        db.execute_batch(&alter_table_stmts)?;
        let mut insert_stmt = db.prepare(&insert_stmt)?;

        let file = File::open(&filename).expect("Could not open file");
        let reader = BufReader::new(file);

        for (n, line) in reader.lines().enumerate() {
            match line {
                Ok(line) => {
                    if let Some(c) = re.captures(&line) {
                        let data = [filename.to_owned(), (n + 1).to_string(), line.clone()];
                        let groups = c
                            .iter()
                            .skip(1) // First item is whole match
                            .map(|g| g.unwrap().as_str().to_string())
                            .collect::<Vec<_>>();

                        let chained = data.iter().chain(groups.iter());

                        insert_stmt.execute(rusqlite::params_from_iter(chained))?;
                    } else if insert_non_matching_stmt.is_some() {
                        insert_non_matching_stmt
                            .as_mut()
                            .unwrap()
                            .execute(rusqlite::params![
                                filename.to_owned(),
                                (n + 1).to_string(),
                                line.clone()
                            ])?;
                    }
                }
                Err(e) => eprintln!("Error: {}", e),
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape() {
        let strings = ["foo.h", "a/b/c.cpp", "hello world.txt", "*.rs"];
        let escaped_strings = ["foo_h", "a_b_c_cpp", "hello_world_txt", "__rs"];

        for (s, e) in strings.iter().zip(escaped_strings.iter()) {
            let esc = escape(s);
            assert_eq!(esc.is_ok(), true);

            let esc = esc.unwrap();
            assert_eq!(e, &esc);
        }
    }
    #[test]
    fn test_sql_generation() {
        let table_name = "foo";

        for pattern in [r#"(?P<tag>.*)(?:\s+)(?P<value>.*)"#, ""] {
            let re = regex::Regex::new(pattern).unwrap();

            let db = Connection::open_in_memory().unwrap();

            let stmt = create_table_stmt(table_name);
            assert_eq!(db.execute_batch(&stmt).is_ok(), true);

            let (i, a) = generate_insert_and_alter(&re, table_name);

            assert_eq!(db.execute_batch(&a).is_ok(), true);

            let insert_stmt = db.prepare(&i);
            assert_eq!(insert_stmt.is_ok(), true);

            let mut insert_stmt = insert_stmt.unwrap();
            assert_eq!(
                insert_stmt.parameter_count(),
                re.captures_len() + DEFAULT_ROWS - 1,
                "Insert statement inserts three columns + matched groups"
            );

            let get_stmt = db.prepare("select * from foo");
            assert_eq!(get_stmt.is_ok(), true);

            let get_stmt = get_stmt.unwrap();
            assert_eq!(
                get_stmt.column_count(),
                re.captures_len() + DEFAULT_ROWS - 1,
                "get statement tests the number of columns in the table"
            );
        }
    }
}
